
I want to create a Python server that allows downloading a video using the yt-dlp CLI, and then exposes a public HTTPS URL through which I can fetch this video.

[https://github.com/yt-dlp/yt-dlp](https://github.com/yt-dlp/yt-dlp)

Here is a description of the API that this server must expose:

* an operation `initiateDownload` that:

  * takes as parameters

    * `String videoURL`
    * `List<String> ytdlpCLIParameters` that allows specifying additional yt-dlp parameters if needed. A predefined set of mandatory parameters must always be applied (format, file naming).
  * returns an UUID if the download starts successfully, or an error code otherwise.

* an operation `listDownloads` with:

  * parameters:

    * `int overLastPeriodDurationInMinutes` to restrict the list of returned downloads. Default value: 60.
    * `boolean onlyShowOngoingDownloads` to restrict the list to ongoing downloads only.
  * and return value:

    * `List<struct<String downloadUUID, DownloadStatusEnum downloadStatus, Optional<long DownloadSizeInBytes>, Optional<float progress>>>`

* an operation `getVideoDownloadPublicURL(videoDownloadUUID, URLTypeEnum urlType)` that retrieves the public HTTPS or S3 URL of a downloaded video (or an error such as downloadFailed or downloadNotReady).

  * with `URLTypeEnum = {HTTPS, S3}`

---

### System State Storage

* The implementation must store the state of downloads and other metadata in a sqlite database located at `/opt/prt/prt-videodownloader/db/prt-videodownloader.sqlite`.
  This location can be overridden using the environment variable `PRT_VIDEODOWNLOADER_SQLITEFILEPATH`.
* The `DownloadStatusEnum` must have a precise set of values (e.g. PENDING, DOWNLOADING, COMPLETED, FAILED, ...).
* Use SQLAlchemy.

---

### Video Storage

* The server must store videos under `/opt/prt/prt-videodownloader/data/`.
  This location can be overridden using the environment variable `PRT_VIDEODOWNLOADER_VIDEODATAPATH`.
* To track download progress, we will use yt-dlp‚Äôs `--progress-template`.

---

### Publishing Videos via HTTP/HTTPS and S3

* For HTTP, the Python server must expose URLs under the baseURL `https://prt.teevity.com/videodownloader` (which can be overridden with the env var `PRT_VIDEODOWNLOADER_HTTPSBASEURL`). The Python server itself only exposes HTTP and only accepts requests from the local network.
* For HTTPS, nginx will run in another container (the download folder will be shared via the host disk).
* For S3, the system itself implements the Object Storage layer (it does not push videos to S3). We will use RustFS ([https://github.com/rustfs/rustfs](https://github.com/rustfs/rustfs)) running in another container.
* The host download folder (`/opt/prt/prt-videodownloader/data/`) is therefore shared between all these containers.

---

### Error Format

* I want a uniform error format:

  ```json
  { "errorCode": "XYZ", "errorMessage": "‚Ä¶" }
  ```

  combined with an HTTP error code that must always be `418 (I'm a teapot)` because that‚Äôs the convention in my code (to avoid confusion with technical errors such as hitting the wrong endpoint).

---

### Security

* For HTTPS, nginx sits ‚Äúin front of‚Äù the Python server (and possibly in front of rustfs).
* The system will be IP-protected and not exposed publicly, so no authentication is required for now.
* Python, nginx, and rustfs servers must all accept connections from outside (not just 127.0.0.1).

---

### API and OpenAPI

* I prefer Flask (which I already know) over FastAPI.
* I want an OpenAPI description of the API, using the flask-openapi3 extension.

---

### Deployment

* I want to use Docker and docker-compose to publish the application.
* I want a `docker-compose.yml` file defining the different containers (`prt-videodownloader-api`, `prt-videodownloader-nginx`, `prt-videodownloader-rustfs`).
* For the internal Docker bridge network, the name must be `prt-videodownloader-net`.
* Logs should go to stdout/stderr (so we can use `docker logs ...`).

---

### Web UI

* I also need a simple Web UI!
* I want a lightweight UI built with Angular.
* No real-time progress tracking (the user will click refresh instead).
* The Angular UI will be served via nginx.

---

I will create this project with Junie, IntelliJ‚Äôs coding agent.
Can you break down my description into successive tasks (so I can copy-paste them into Junie)?

---

üëâ Do you also want me to **rewrite your spec into a task plan** (like a backlog / roadmap format), or just keep it as-is but in English?
