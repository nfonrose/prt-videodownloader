
---

## üìã Task Plan for Junie

### **Phase 1 ‚Äì Project Foundations**

1. **Initialize the project**

   * Create a Python project using Flask.
   * Add support for `flask-openapi3` and generate a minimal OpenAPI description (just a ‚Äúhello world‚Äù endpoint).
   * Configure SQLAlchemy with a SQLite database.
   * The database file path must be configurable with the environment variable `PRT_VIDEODOWNLOADER_SQLITEFILEPATH` (default `/opt/prt/prt-videodownloader/db/prt-videodownloader.sqlite`).

2. **Define data models**

   * Create SQLAlchemy models for:

     * `Download` with fields: `uuid`, `videoURL`, `status`, `sizeInBytes`, `progress`, `createdAt`, `updatedAt`.
   * Define `DownloadStatusEnum` with values: `PENDING`, `DOWNLOADING`, `COMPLETED`, `FAILED`.

---

### **Phase 2 ‚Äì Core API Endpoints**

3. **Implement `initiateDownload` endpoint**

   * Parameters: `videoURL`, `ytdlpCLIParameters`.
   * Apply a predefined set of mandatory parameters (format, file naming).
   * Start a download process using `yt-dlp`.
   * Store metadata in the SQLite DB with status `PENDING` or `DOWNLOADING`.
   * Return a UUID if download starts, or an error `{ "errorCode": "...", "errorMessage": "..." }` with HTTP 418 otherwise.

3bis. In the `initiateDownload` endpoint, track what's happening for each `yt-dlp` process to properly update the DownloadStatusEnum

   * In the initiateDownload method, track the execution status of each `yt-dlp` process to properly update the DownloadStatusEnum
     At the end of the execution of each `yt-dlp` process, log a line that indicate the return code (associated with the download UUID)

   * In the initiateDownload method, track the `yt-dlp` stdout/stderr to detect the download progress update and the actual outcome
     in order to properly update the DownloadStatusEnum

4. **Implement `listDownloads` endpoint**

   * Parameters:

     * `overLastPeriodDurationInMinutes` (default = 60).
     * `onlyShowOngoingDownloads` (boolean).
   * Return list of downloads with fields:

     * `downloadUUID`, `downloadStatus`, `downloadSizeInBytes` (optional), `progress` (optional).

5. **Implement `getVideoDownloadPublicURL` endpoint**

   * Parameters: `videoDownloadUUID`, `URLTypeEnum={HTTPS,S3}`.
   * Return the public URL or an error (`downloadFailed` / `downloadNotReady`).


5. **Implement `redirectToHTTPSVideoDownloadPublicURL` endpoint**

   Implement a new Flask endpoint called redirectToHTTPSVideoDownloadPublicURL.
   
   Behavior:
   The endpoint accepts query parameters:
    - video_id (required): the ID of the video download task.
    - retryCounter (optional, default 0): number of times this endpoint has redirected so far.
   
   The endpoint calls list_downloads(video_id) to check if the video is available.
    - If the download is complete: Immediately return an HTTP 302 redirect to the public HTTPS URL of the video.
    - If the download is not complete yet: 
        - Sleep for a few seconds (e.g., 3).
        - Call list_downloads(video_id) again.
        - If now ready ‚Üí return 302 redirect to the public URL.
        - If still not ready ‚Üí return HTTP 302 redirect back to the same endpoint (redirectToHTTPSVideoDownloadPublicURL) but with retryCounter incremented by 1.
   
   The endpoint must stop retrying after a maximum number of attempts (configurable, e.g., MAX_RETRIES = 5).
   
   If the retry counter exceeds this limit ‚Üí return a 418 status with an ErrorResponse with "Download not ready in time" }.
   
   Example request flow:
   ```
   GET /redirectToH   TTPSVideoDownloadPublicURL?video_id=abc123
   ‚Üí 302 Location: /redirectToHTTPSVideoDownloadPublicURL?video_id=abc123&retryCounter=1
   ‚Üí 302 Location: /redirectToHTTPSVideoDownloadPublicURL?video_id=abc123&retryCounter=2
   ‚Üí ‚Ä¶ until download ready ‚Ä¶
   ‚Üí 302 Location: https://your-nginx-domain/videos/abc123.mp4
   ```

---

### **Phase 3 ‚Äì Download Execution**

6. **Download worker & progress tracking**

   * Use `subprocess` to run `yt-dlp` with `--progress-template`.
   * Parse progress and update SQLite database.
   * Store downloaded files in `/opt/prt/prt-videodownloader/data/` (configurable via `PRT_VIDEODOWNLOADER_VIDEODATAPATH`).

---

### **Phase 4 ‚Äì Video Publication**

7. **HTTP serving from Flask**

   * Expose videos under a configurable base URL `PRT_VIDEODOWNLOADER_HTTPSBASEURL` (default: `https://prt.teevity.com/videodownloader`).
   * Flask itself only serves HTTP and only accepts local network requests.

8. **Integrate nginx (separate container)**

   * Configure nginx to serve static files from the shared folder.
   * Provide HTTPS termination in front of Flask.

9. **Integrate RustFS (separate container)**

   * Add RustFS container for S3-like object storage.
   * Mount the shared video folder `/opt/prt/prt-videodownloader/data/`.

---

### **Phase 5 ‚Äì Deployment Setup**

10. **Create `docker-compose.yml`**

    * Define services:

      * `prt-videodownloader-api` (Flask app).
      * `prt-videodownloader-nginx` (serving Angular UI + HTTPS).
      * `prt-videodownloader-rustfs` (object storage).
    * Define shared volume for video data.
    * Use internal Docker network `prt-videodownloader-net`.
    * Route logs to stdout/stderr.

---

### **Phase 6 ‚Äì Error Handling & Security**

11. **Implement uniform error handling**

    * Always return JSON: `{ "errorCode": "...", "errorMessage": "..." }`.
    * Always return HTTP status `418`.

12. **Configure network security**

    * Ensure Flask, nginx, and RustFS accept external connections (not restricted to `127.0.0.1`).
    * The system will be IP-filtered externally (no authentication for now).

---

### **Phase 7 ‚Äì Web UI**

13. **Create Angular Web UI**

    * A simple Angular app that can:

      * Trigger `initiateDownload`.
      * Call `listDownloads` and display results.
      * Request a video URL with `getVideoDownloadPublicURL`.
    * No real-time updates; the user will manually refresh.

14. **Serve Angular app via nginx**

    * Build Angular and serve static files through nginx.
    * Ensure the UI calls the Flask API endpoints correctly.

---

‚úÖ This plan is incremental: you can submit tasks one by one to Junie without overwhelming it.
Each phase builds on the previous ones and results in a functional component of your system.

---

Do you want me to **format each of these tasks into short prompts ready to paste into Junie**, or do you prefer to keep this higher-level breakdown and adapt the prompts yourself?
